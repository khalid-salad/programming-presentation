<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Programming Tips</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/moon.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">
# Programming Tips</script></section><section  data-markdown><script type="text/template">## Table of Contents
<style>
.container{
    display: flex;
}
.col{
    flex: 1;
}
</style>

<div class="container">

<div class="col">

* Introduction <!-- .element class="fragment" -->
  * Correctness <!-- .element class="fragment" -->
  * Readability <!-- .element class="fragment" -->
  * Performance <!-- .element class="fragment" -->
</div>

<div class="col">

* Problem Solving <!-- .element class="fragment" -->
  * Subroutines <!-- .element class="fragment" -->
  * Debugging <!-- .element class="fragment" -->
  * Example <!-- .element class="fragment" -->
</div></script></section><section  data-markdown><script type="text/template">
## Introduction
### Things to Consider <!-- .element class="fragment" -->
Good code depends on <!-- .element class="fragment" -->
* Correctness <!-- .element class="fragment" -->
* Readability <!-- .element class="fragment" -->
* Performance <!-- .element class="fragment" --></script></section><section ><section data-markdown><script type="text/template">## Correctness
* Code needs to be correct <!-- .element class="fragment" -->
* If code is incorrect, then it doesn't matter <!-- .element class="fragment" -->
  * how performant it is <!-- .element class="fragment" -->
  * how readable it is <!-- .element class="fragment" --></script></section><section data-markdown><script type="text/template">
### For example 
```python
def bool_sat(formula):
    return True
```
<!-- .element class="fragment" -->
* $\mathcal{O}(1)$ solution to an NP-Complete problem <!-- .element class="fragment" -->
* but, obviously not a correct solution <!-- .element class="fragment" --></script></section><section data-markdown><script type="text/template">
## What does "correct" mean?
* Depends on context, e.g. consider software that <!-- .element class="fragment" -->
  * controls a commercial plane <!-- .element class="fragment" -->
    * must be provably (mathematically) correct <!-- .element class="fragment" -->
  * launches League of Legends <!-- .element class="fragment" -->
    * 80% test coverage is sufficient <!-- .element class="fragment" --> </script></section><section data-markdown><script type="text/template"><style>
.container{
    display: flex;
}
.col{
    flex: 1;
}
</style>

### Testing
<div class="container">

<div class="col">

* You should always test your code
* This is the easiest way to catch bugs! <!-- .element class="fragment" -->
* For example <!-- .element class="fragment" -->

```python
def is_prime(n):
  if n in {0, 1}:
    return False
  else:
    sqrtn = int(n ** 0.5)
    for i in range(2, sqrtn):
      if n % i == 0:
        return False
    return True
```
<!-- .element class="fragment" -->
</div>

<div class="col">

* What is wrong with this code? <!-- .element class="fragment" -->
* May not be immediately obvious <!-- .element class="fragment" -->
  * So let's test it <!-- .element class="fragment" -->

```python
for i in range(2, 11):
  print(i, is_prime(i))
```
<!-- .element class="fragment" -->
</div></script></section><section data-markdown><script type="text/template"><style>
.container{
    display: flex;
}
.col{
    flex: 1;
}
</style>

<div class="container">

<div class="col">

| $i$  | `is_prime(i)` | Correct? |
|------|---------------|----------|
| $2$  | `True`        | ✓        |
| $3$  | `True`        | ✓        |
| $4$  | `True`        | ✗        |
| $5$  | `True`        | ✓        |
| $6$  | `True`        | ✗        |
| $7$  | `True`        | ✓        |
| $8$  | `True`        | ✗        |
| $9$  | `True`        | ✗        |
| $10$ | `False`       | ✓        |
</div>


<div class="col", style="font-size:25px">

* Incorrect for composite values $4$, $6$, $8$, and $9$ <!-- .element class="fragment" -->
* For these values $\lfloor\sqrt{n}\rfloor = 2$ <!-- .element class="fragment" -->
* Off-by-one error — add 1 to the range: <!-- .element class="fragment" -->
  * `int(n ** 0.5) + 1`
</div>
</div></script></section><section data-markdown><script type="text/template">
## Edge Cases
* <!-- .element class="fragment" --> Be sure to test for <font color="red">edge cases</font> 
  * boundary or degenerate cases <!-- .element class="fragment" -->
    * <!-- .element class="fragment" --> sorting an <font color="red">empty list</font> 
    * <!-- .element class="fragment" --> binary search returning <font color="red">first</font> or <font color="red">last</font> index 
    * <!-- .element class="fragment" --> checking if 0 or 1 is <font color="red">prime</font>
    * <!-- .element class="fragment" --> traversing a graph with <font color="red">no edges</font>
* <!-- .element class="fragment" --> Depending on the context, you may also need to test for <font color=red>invalid inputs</font></script></section></section><section ><section data-markdown><script type="text/template">## Readability
* <!-- .element class="fragment" --> Usually the most important thing after correctness 
* <!-- .element class="fragment" --> Code will be <font color="red">read</font> far more often than it is <font color="red">written</font>
* <!-- .element class="fragment" --> <font color=red>Maintenance</font> of code is often the highest expense</script></section><section data-markdown><script type="text/template">## Syntax
* <!-- .element class="fragment" --> Follow a set of best-practices for your language. For example
  * <!-- .element class="fragment" --> In Python, there is PEP 8
  * <!-- .element class="fragment" --> IN C, there is the Linux Kernel Style
* <!-- .element class="fragment" --> The style chosen is less important than that you <font color=red>follow a consistent style</font></script></section><section data-markdown><script type="text/template">## For Example
<div class="container">

<div class="col">

<fieldset style="border: 2px groove">
      <legend style="border: 2px groove;margin-left: -4em; padding:10px "><font color=white>ugly</font></legend>

```python[]
c=(a+b)**0.5
L=[1,2,7]
```

</div>


</fieldset>


<div class="col">

<fieldset style="border: 2px groove">
      <legend style="border: 2px groove;margin-left: -3em; padding:10px "><font color=white>readable</font></legend>

```python[]
c = (a + b) ** 0.5
L = [1, 2, 7]
```

</div>

</fieldset>

</div>

* <!-- .element class="fragment" --> The easiest way to be consistent is to use a formater
  * <!-- .element class="fragment" --> A formatter automatically formats your code
    * Black, yapf, autopep, etc. for Python
    * clang-format for C/C++


<aside class="notes"><p>notice that, while the <em>semantics</em> of both sets of code are the same, the code on the left is
more cluttered and difficult to read.</p>
</aside></script></section><section data-markdown><script type="text/template">## Structure
* Syntactic readability (style) is not enough
* Code should be written for readability
* <font color=red>Modular</font> and <font color=red>structured</font> code is easier to
  * read
  * write
  * debug</script></section><section data-markdown><script type="text/template">## Example Problem
* Consider the following problem
<fieldset style="border: 2px groove; padding:10px">
      <legend style="border: 2px groove;margin-left: -3em; padding:10px "><font color=white>Problem</font></legend>
Find the largest product of two $3$-digit numbers that is a palindrome. 
</fieldset>
<fieldset style="border: 2px groove; padding:10px">
      <legend style="border: 2px groove;margin-left: -3em; padding:10px "><font color=white>Brute Force Solution</font></legend>
Iterate through all $10^6$ pairs of products and check if they are palindromic while keeping track of max.
</fieldset>
</script></section><section data-markdown><script type="text/template">## Bad Structure

<div class="container">

<div class="col">

```python[|1|2|3-8|9-10|1]
for a, b in pairs:
  prod = a * b
  is_palindrome = True
  n = len(str(prod))
  for i in range(n):
    if s[i] != s[n - i - 1]:
      is_palindrome = False
      break
  if not is_palindrome:
    continue
  else:
    if prod > biggest:
      biggest = prod
```

</div>

<div class="col">

* <!-- .element class="fragment" --> Code is hard to follow
* <!-- .element class="fragment" --> Unnecessarily complex — <code>is_palindrome</code> is essentially a sentinel value
* <!-- .element class="fragment" --> code is <font color=red>imperative</font>, not <font color=red>declarative</font>

</div>

</div></script></section><section data-markdown><script type="text/template">
## Better Structure
<div class="container">

<div class="col">

```python
def is_palindrome(num):
  n = len(str(num))
  for i in range(n):
    if s[i] != s[n - i - 1]:
      return False
  return True

biggest = 0
for a, b in pairs:
  prod = a * b
  if is_palindrome(prod):
    biggest = max(biggest, prod)
```

</div>

<div class="col">

* <!-- .element class="fragment" --> Code is much easier to follow
* <!-- .element class="fragment" --> Function <code>is_palindrome</code> clearly conveys intent
* <!-- .element class="fragment" --> code is <font color=red>declarative</font>

</div>

</div></script></section><section data-markdown><script type="text/template">
## Good Structure
<div class="container">

<div class="col">

```python
def is_palindrome(num):
  n = len(str(num))
  for i in range(n):
    if s[i] != s[n - i - 1]:
      return False
  return True

def main():
  biggest = 0
  for a, b in pairs:
    prod = a * b
    if is_palindrome(prod):
      biggest = max(biggest, prod)
  print(biggest)
```

</div>

<div class="col">

* <!-- .element class="fragment" --> Basically the same code
* <!-- .element class="fragment" --> <code>main</code> describes what the code is doing <font color=red>overall</font>

</div>

</div>
</script></section><section data-markdown><script type="text/template">
## Comments
* <!-- .element class="fragment" --> Code should be commented
* <!-- .element class="fragment" --> but not <font color=red>over commented</font>

<fieldset style="border: 2px groove">
      <legend style="border: 2px groove;margin-left: -4em; padding:10px "><font color=white>Bad Comment</font></legend>

```python[]
def i_sqrt(n):
  i = 0
  while i ** 2 < n:
    i += 1  # increment i
  return i
```

</fieldset>

<!-- .element class="fragment" --> 

* <!-- .element class="fragment" --> it is clear that <code>i += 1</code> increments <code>i</code>
* <!-- .element class="fragment" --> comment is superfluous and <font color=red>distracting</font>
</script></section><section data-markdown><script type="text/template">## Good Comments
* As a rule of thumb
  * good <font color=red>code</font> describes <font color=red>what</font> and <font color=red>how</font>
  * good <font color=red>comments</font> describe <font color=red>why</font></script></section><section data-markdown><script type="text/template">## Good Comment Example

<fieldset style="border: 1px groove">
      <legend style="border: 1px groove;margin-left: -4em; padding:3px "><font color=white>Good Comment</font></legend>

```python[|3]
def is_prime(n):
  ...
  # we need only check for odd factors up to sqrt(n)
  for i in range(3, int(n ** 0.5) + 1), 2):
    if n % i == 0:
      return False
  return True
```

</fieldset>

<!-- .element class="fragment" fragment-id=1--> 


* <!-- .element class="fragment" fragment-id=2--> this comment explains why the code is iterating through $3$, $5$, $\dots$, $\lfloor\sqrt{n}\rfloor$
* <!-- .element class="fragment" --> without this comment, the reader would have to determine for themself why it only checks odd numbers up to $\lfloor\sqrt{n}\rfloor$
</script></section><section data-markdown><script type="text/template">## Good Code
* <!-- .element class="fragment" --> If your code is well-written, it will improve readability
* <!-- .element class="fragment" --> Not just in terms of structure, but things like variable and function names</script></section><section data-markdown><script type="text/template">## Good Code
* <!-- .element class="fragment" --> Well-written code often makes many comments <font color=red>unecessary</font>
* <!-- .element class="fragment" --> Often expressed as
> Good Code is its Own Best Documentation
<!-- .element class="fragment" -->
* <!-- .element class="fragment" --> Not an excuse to avoid comments
</script></section><section data-markdown><script type="text/template">## Bad Naming
```python[|6|]
def qs(a):
  if len(a) <= 1:
    return a
  else:
    x, z = [], []
    y = a[0]
    for p in a:
      if p < y:
        x.append(p)
      else:
        z.append(p)
    return qs(x) + qs(z)
```
<!-- .element class="fragment" -->
* <!-- .element class="fragment" --> These names convey almost <font color=red>nothing</font> about the meaning of the code
</script></section><section data-markdown><script type="text/template">## Good Naming
```python[|6|]
def quicksort(array):
  if len(array) <= 1:
    return array
  else:
    left, right = [], []
    pivot = array[0]
    for ele in array:
      if ele < pivot:
        left.append(ele)
      else:
        right.append(ele)
    return quicksort(left) + quicksort(right)
```
<!-- .element class="fragment" -->

* <!-- .element class="fragment" --> These names convey
  * <!-- .element class="fragment" --> function is quicksort
  * <!-- .element class="fragment" --> input is an array
  * <!-- .element class="fragment" --> left and right are partitions around pivot = array[0]
  * <!-- .element class="fragment" --> ele iterates through values of array
</script></section><section data-markdown><script type="text/template">## Side by Side

<div class="container">


<div class="col">


```python
def qs(a):
  if len(a) <= 1:
    return a
  else:
    x, z = [], []
    y = a[0]
    for p in a:
      if p < y:
        x.append(p)
      else:
        z.append(p)
    return qs(x) + qs(z)
```

</div>


<div class="col">


```python
def quicksort(array):
  if len(array) <= 1:
    return array
  else:
    left, right = [], []
    pivot = array[0]
    for ele in array:
      if ele < pivot:
        left.append(ele)
      else:
        right.append(ele)
    return quicksort(left) + quicksort(right)
```

</div>

</div>
</script></section><section data-markdown><script type="text/template">## Miscellaneous
* <!-- .element class="fragment" --> Impractical to create exhaustive list of best practices
  * <!-- .element class="fragment" --> and some practices are debateable
* <!-- .element class="fragment" --> Good idea to look at resources like
  * <!-- .element class="fragment" --> The Little Book of Python Anti-Patterns
  * <!-- .element class="fragment" --> The C++ Core Guidelines
* <!-- .element class="fragment" --> And to use a <font color=red>linter</font> — a static analysis tool to flag bugs, style errors, etc., like
  * <!-- .element class="fragment" --> flake8 for Python
  * <!-- .element class="fragment" --> clang-tidy for C++
</script></section></section><section  data-markdown><script type="text/template">## Performance</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"parallaxBackgroundImage":"images/backdrop.png","parallaxBackgroundSize":"2000px 1125px"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
